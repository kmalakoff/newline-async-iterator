{"version":3,"sources":["../../src/index.ts"],"names":["hasIterator","Symbol","asyncIterator","newlineIterator","source","string","done","sourceIterator","generateNext","Promise","resolve","reject","index","skip","length","next","then","value","undefined","iterator","result","line","substr"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAG,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,aAA5D;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,SAASC,eAAT,CACbC,MADa,EAEkB;AAC/B,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,IAAI,GAAG,KAAX;AAEA;;AACA,MAAMC,cAAc,GAAGP,WAAW,GAAGI,MAAM,CAACH,MAAM,CAACC,aAAR,CAAN,EAAH,GAAoCE,MAAtE;AACA;;AAEA,WAASI,YAAT,GAA2C;AACzC,WAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,iBAAsB,gCAAeN,MAAf,EAAuB,CAAvB,EAA0B,IAA1B,CAAtB;AAAA;AAAA,UAAOO,KAAP;AAAA,UAAcC,IAAd;;AACA,UAAID,KAAK,IAAI,CAAb,EAAgB;AACd,YAAIA,KAAK,KAAKP,MAAM,CAACS,MAAP,GAAgB,CAA1B,IAA+BT,MAAM,CAACO,KAAD,CAAN,KAAkB,IAArD,EAA2D,OAAOF,OAAO,CAAC,CAACE,KAAD,EAAQC,IAAR,CAAD,CAAd;AAC5D;;AACD,UAAIP,IAAJ,EAAU,OAAOI,OAAO,CAAC,CAACE,KAAD,EAAQC,IAAR,CAAD,CAAd;AACVN,MAAAA,cAAc,CAACQ,IAAf,GAAsBC,IAAtB,CAA2B,UAAUD,IAAV,EAAgB;AACzC,YAAIA,IAAI,CAACT,IAAT,EAAeA,IAAI,GAAG,IAAP;AACf,YAAIS,IAAI,CAACE,KAAL,KAAeC,SAAnB,EAA8Bb,MAAM,IAAI,2BAAWU,IAAI,CAACE,KAAhB,CAAV;AAC9BT,QAAAA,YAAY,GAAGQ,IAAf,CAAoBN,OAApB,WAAmCC,MAAnC;AACD,OAJD;AAKD,KAXM,CAAP;AAYD;;AAED,MAAMQ,QAAQ,GAAG;AACfJ,IAAAA,IADe,kBACkC;AAC/C,aAAO,IAAIN,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5CH,QAAAA,YAAY,GACTQ,IADH,CACQ,iBAAyB;AAAA;AAAA,cAAdJ,KAAc;AAAA,cAAPC,IAAO;;AAC7B,cAAID,KAAK,GAAG,CAAZ,EAAe;AACb,gBAAI,CAACP,MAAM,CAACS,MAAZ,EAAoB,OAAOJ,OAAO,CAAC;AAAEO,cAAAA,KAAK,EAAEC,SAAT;AAAoBZ,cAAAA,IAAI,EAAE;AAA1B,aAAD,CAAd;AACpB,gBAAMc,MAAuC,GAAG;AAAEH,cAAAA,KAAK,EAAEZ,MAAT;AAAiBC,cAAAA,IAAI,EAAE;AAAvB,aAAhD;AACAD,YAAAA,MAAM,GAAG,EAAT;AACA,mBAAOK,OAAO,CAACU,MAAD,CAAd;AACD;;AACD,cAAMC,IAAI,GAAGhB,MAAM,CAACiB,MAAP,CAAc,CAAd,EAAiBV,KAAjB,CAAb;AACAP,UAAAA,MAAM,GAAGA,MAAM,CAACiB,MAAP,CAAcV,KAAK,GAAGC,IAAtB,CAAT;AACA,iBAAOH,OAAO,CAAC;AAAEO,YAAAA,KAAK,EAAEI,IAAT;AAAef,YAAAA,IAAI,EAAE;AAArB,WAAD,CAAd;AACD,SAXH,WAYSK,MAZT;AAaD,OAdM,CAAP;AAeD;AAjBc,GAAjB;;AAoBA,MAAIX,WAAJ,EAAiB;AACfmB,IAAAA,QAAQ,CAAClB,MAAM,CAACC,aAAR,CAAR,GAAiC,YAAmC;AAClE,aAAO,IAAP;AACD,KAFD;AAGD;;AAED,SAAOiB,QAAP;AACD","sourcesContent":["import indexOfNewline from \"index-of-newline\";\nimport decodeUTF8 from \"./decodeUTF8\";\n\nconst hasIterator = typeof Symbol !== \"undefined\" && Symbol.asyncIterator;\n\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.asyncIterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-async-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */\n\nexport default function newlineIterator(\n  source: AsyncIterable<Uint8Array> | AsyncIterator<Uint8Array>\n): AsyncIterableIterator<string> {\n  let string = \"\";\n  let done = false;\n\n  /* c8 ignore start */\n  const sourceIterator = hasIterator ? source[Symbol.asyncIterator]() : source;\n  /* c8 ignore stop */\n\n  function generateNext(): Promise<number[]> {\n    return new Promise(function (resolve, reject) {\n      const [index, skip] = indexOfNewline(string, 0, true) as number[];\n      if (index >= 0) {\n        if (index !== string.length - 1 || string[index] === \"\\n\") return resolve([index, skip]);\n      }\n      if (done) return resolve([index, skip]);\n      sourceIterator.next().then(function (next) {\n        if (next.done) done = true;\n        if (next.value !== undefined) string += decodeUTF8(next.value);\n        generateNext().then(resolve).catch(reject);\n      });\n    });\n  }\n\n  const iterator = {\n    next(): Promise<IteratorResult<string, boolean>> {\n      return new Promise(function (resolve, reject) {\n        generateNext()\n          .then(function ([index, skip]) {\n            if (index < 0) {\n              if (!string.length) return resolve({ value: undefined, done: true });\n              const result: IteratorResult<string, boolean> = { value: string, done: false };\n              string = \"\";\n              return resolve(result);\n            }\n            const line = string.substr(0, index);\n            string = string.substr(index + skip);\n            return resolve({ value: line, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (hasIterator) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<string> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<string>;\n}\n"],"file":"index.js"}